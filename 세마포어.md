- 프로세스 사이에 그들의 동작을 동기화할때 사용
	- ex) 동시에 여러 프로세스가 공유 메모리에 접근하여 값을 갱신하려 할 때, 공유 메모리 블록을 동기화
- 커널이 관리하는 정수값으로, 0 이하로 절대 떨어질 수 없음
- 프로세스의 동작을 제어하는 것이 아니라, 프로세스가 만든 연관에 의해 그 의미가 결정됨
## POSIX 세마포어
- 리눅스에는 시스템 V 세마포어와 POSIX 세마포어가 있음
- 같은 역할을 하지만 구현이 다름. 여기서는 POSIX 세마포어를 알아볼 것
### 세마포어 열기
~~~c
#include <fcntl.h> // O_* 상수 정의
#include <sys/stat.h> // 모드 상수 정의
#include <semaphore.h> 

sem_t *sem_open(const char *name, int oflag, ...);
~~~
- sem_open() 함수는 새로 기명 세마포어를 생성하고 열거나, 기존 세마포어를 오픈
- name 인자는 세마포어를 식별
- oflag 인자는 기존 세마포어를 열지, 새로운 세마포어를 생성하고 열지를 나타내는 비트마스크
	- oflag가 0이면 기존 세마포어에 접근
	- O_CREATE이면 주어진 name이 이미 존재하지 않는 경우 새로운 세마포어가 생성됨
	- O_CREATE와 O_EXCL 모두에 명시되고, 주어진 name의 세마포어가 이미 존재하면 open 실패
- O_CREATE가 flag에 명시되면, mode와 value라는 두 가지 인자가 추가로 요구됨
	- mode 인자는 새로운 세마포어가 가질 권한을 명시
	- 세마포어의 값을 읽고 수정해야 하기 때문에 대부분 접근 모드는 O_RDWR로 가정
	- value 인자는 새로운 세마포어에 할당되는 초기값을 명시하는 부호 없는 정수
- sem_open()은  sem_t 값의 포인터를 리턴. 에러시 SEM_FAILED값을 리턴
### 세마포어 종료
~~~c
#include <semaphore.h>

int sem_close(sem_t *sem);
~~~
- 프로세스가 세마포어를 열 때, 시스템은 프로세스와 세마포어 간의 관계를 기록
	- close함수는 이러한 관계를 제거하고, 관련된 자원을 해제하며, 세마포어를 참조하는 프로세스의 수를 감소시킴
- 열린 세마포는 프로세스가 종료되거나 프로세스가 exec()를 실행하는 경우 자동으로 종료됨
- 세마포어를 닫는다고 해서 해당 세마포어가 제거되는 것은 아님
### 세마포어 제거
~~~c
#include <semaphore.h>

int sem_unlink(const char *name);
~~~
- name으로 식별되는 세마포어를 제거하고, 모든 프로세스가 사용을 중지하면 제거됐다고 표시함
### 세마포어 대기
~~~c
#include <semaphore.h>

int sem_wait(sem_t *sem);
~~~
- sem이 참조하는 세마포어의 값을 1씩 감소시킴
- 세마포어의 값이 현재 0보다 큰 경우 sem_wait()은 즉시 리턴
- 세마포어의 값이 0이면 값이 0보다 커질때까지 블록하고, 커지는 시점에 감소되고 리턴
- 비블로킹 버전인 sem_trywait(), 블로고딜 시간 한도를 명시하는 sem_timedwait()도 있음
### 세마포어 게시
~~~c
#include <semaphore.h>

int sem_post(sem_t *sem);
~~~
- sem이 참조하는 세마포어의 값을 1씩 증가시킴
- sem_post() 호출 이전의 세마포어 값이 0이고, 몇몇 다른 프로세스가 세마포어를 감소시키려다가 블록된 경우, 해당 프로세스는 깨어나고 그 프로세스의 sem_wait() 호출은 세마포어를 감소시킴
- 여러 프로세스가 sem_wait()에 블록된 경우, 어떤 프로세스가 깨어나서 세마포어를 감소시킬지는 알 수 없음

> POSIX 세마포어와 Pthreads 뮤텍스는 둘 다 동일한 프로세스 내의 스레드의 동작을 동기화하는데 사용할 수 있고, 성능도 비슷하다. 그러나 뮤텍스의 소유권 특징이 코드의 좋은 구조를 강제하기 때문에 (뮤텍스를 잠근 스레드만이 해제할 수 있다) 뮤텍스가 흔히 선호된다. 반대로, 세마포어는 다른 스레드가 세마포어의 값을 변화시킬 수 있기에 이런 유연성은 좋지 않은 동기화 설계를 유발할 수 있다.