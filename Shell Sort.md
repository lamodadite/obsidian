## 시간복잡도
- 최선 : nlogn / nlog^2n
- 평균 : depends on gap sequence
- 최악 : nlog^2n / n^2
## 장점
- 멀리 있는 원소들끼리 빠르게 비교 및 교환이 이루어짐
- Insertion Sort, Bubble Sort에 비해 정렬 속도가 빠름
## 단점
- 일반적인 삽입정렬에 비해 구현이 까다로움
- 갭 시퀀스에 영향을 많이 받음
- 안정정렬이 아님

## 정렬 로직
1. 임의의 간격(gap)을 설정
2. 각 간격별로 분류 된 부분 리스트에 대해 삽입정렬 수행
3. 각 부분 리스트의 정렬이 끝나면 간격을 줄임
4. 간격이 1이 될 때까지 2번 과정으로 되돌아가며 반복
![[Pasted image 20231108211808.png]]
- 위 그림과 같이 일정 간격의 원소들끼리 삽입정렬을 시도하면서 간격을 점차 줄여나가면 됨
- 일정 간격 만큼 패스하면서 '거의 정렬된 상태'로 만들고 최종적으로 마지막에 gap이 1인 삽입정렬을 시도하면 성능이 기존의 삽입 정렬보다 우수해짐
## 갭 시퀀스
- 임의의 간격은 어떻게 정해야 가장 효율적인가?
- 많은 사람들이 경험에 따라 최선의 시퀀스들을 이미 만들어 놓았음
- 이 중 Ciura 시퀀스가 가장 퍼포먼스가 좋으므로, 이를 사용할것
- Ciura 시퀀스 = {1, 4, 10, 23, 57, 132, 301, 701, 1750}
- 1750보다 리스트의 범위가 더 크다면 2.25씩 곱하며 확장하면 됨
- ``{ 1, 4, 10, 23, 57, 132, 301, 701, 1750, 3937, ``
	`8858, 19930, 44842, 100894, 227011, 510774,
	`1149241, 2585792, 5818032, 13090572, 29453787, 
	`66271020, 149109795, 335497038, 754868335, 1698453753};
- int_max는 약 21억을 넘지 못하므로 1698453753까지만 고려함
## 코드
~~~C
void insertion_sort_using_gap(int *list, int start, int size, int gap)
{
	for (int i = start + gap; i < size; i += gap)
	{
		for (int j = i; j >= start + gap; j -= gap)
		{
			if (list[j - gap] > list[j])
				swap(list, j - gap, j);
		}
	}
}

int *shell_sort(int *list, int size)
{
	int GAP_SEQUENCE[] = { 1, 4, 10, 23, 57, 132, 301, 701, 1750, 3937,
	
							8858, 19930, 44842, 100894, 227011, 510774,
							
							1149241, 2585792, 5818032, 13090572, 29453787,
							
							66271020, 149109795, 335497038, 754868335, 1698453753};
	int idx = 0;
	
	// 맨 처음 gap을 참조할 인덱스를 구함
	while (GAP_SEQUENCE[idx] < (int)(size / 2.25))
		idx++;
	// gap sequence만큼 반복
	for (int i = idx; i >= 0; i--)
	{
		for (int j = 0; j < GAP_SEQUENCE[i]; j++)
			insertion_sort_using_gap(list, j, size, GAP_SEQUENCE[i]);
	}
	return (list);
}
~~~
