## Get Next Line
- 이 프로젝트의 목적은 파일 디스크립터로부터 읽혀진, 개행으로 끝나는 한 줄을 반환하는 함수를 코드화 하는 것이다.
## Goals
- 이 프로젝트는 당신의 라이브러리에 아주 편리한 함수를 추가한다.
- 새로운 개념인 static variables([[정적 변수]])에 대해 배운다.
## Common Instructions
- 보너스를 제출하려면, Makefile에 보너스 rule을 포함해야 한다.
- 보너스 과제는 반드시 _bonus.c라는 별도의 파일로 존재해야 한다.
- 메인 파트의 평가와 보너스 파트의 평가는 별도로 이뤄진다.
- 만일 프로젝트에서 libft 사용을 허용한다면, 소스들과 관련 Makefile을 함께 루트 폴더 안에 있는 libft 폴더에 복사해야 한다. 프로젝트의 Makefile은 우선 libft의 Makefile을 사용하여 라이브러리를 컴파일한 다음, 프로젝트를 컴파일해야 한다.
## Mandatory part
- get_next_line()을 여러 번 호출할 때마다, 함수는 한 번에 한 줄씩 파일 디스크립터가 가리키는 텍스트 파일을 읽을 수 있어야 한다.
- 내 함수는 방금 읽어들인 문자열 한 줄을 반환해야 한다. 더 이상 읽어올 것이 없거나 에러가 발생하면 NULL을 반환하여야 한다. 
- 파일에서 읽을 떄, 표준입력으로 읽을 때 모두 함수가 예상대로 동작해야 한다.
- 파일에 끝까지 도달하였고 \\n이 존재하지 않을때를 제외하고, 반환하는 문자열에는 \\n이 포함되어야 한다.  
- 헤더 파일인, get_next_line.h에는 적어도 get_next_line()의 프로토타입이 존재해야 한다.
- get_next_line_utils.c 파일에 필요한 모든 헬퍼 함수들을 추가하라.
- get_next_line() 내에서 파일을 읽어들여야 하므로, 컴파일러 호출에 -D BUFFER_SIZE=n 옵션을 추가하라.
	- 이것은 read()의  buffer size를 지정한다.
	- 평가자와 Moulinette는 코드를 채점할 때 buffer size를 변경할 것이다.
	- -D BUFFER_SIZE 플래그가 없어도 정상적으로 컴파일이 되어야 한다. 기본값은 마음대로 정해도 된다.
	- 예시 : cc -Wall -Wextra -Werror -D BUFFER_SIZE=42 \<files>.c
- 마지막 호출 이후 read()가 파일의 끝에 도달하지 못해 파일 디스크립터가 가리키는 파일이 변경되었으면, get_next_line()이 정의되지 않은 동작을 가진다고 간주한다.
- get_next_line()은 바이너리 파일을 읽을 때 정의되지 않은 동작을 가진다고 간주해야 한다. 그러나 원한다면 이러한 동작을 논리적으로 구현해도 된다.
> BUFFER_SIZE 값이 9999인 경우에도 함수가 여전히 작동하는지? BUFFER_SIZE 값이 1이라면? 100000000이라면? 왜 그런지 아는가?
> 
> get_next_line()이 호출될 때마다 가능한 적게 읽어들이도록 해야 한다. 만약 새로운 줄을 만나면, 현재 줄을 반환해야 한다. 전체 파일을 읽어들인 다음에 한줄씩 처리하지 마라.

## Bonus part
- 정적 변수를 하나만 사용하여 get_next_line()을 개발하라.
- get_next_line()이 여러 개의 파일 디스크립터를 한번에 관리할 수 있어야 한다.
	- 예를 들어, 파일 3, 4, 5에 접근 가능한 경우 디스크립터나 다른 줄에서 fd의 reading thread를 잃지 않은 채로 각 호출당 다른 fd를 읽을수 있어야 한다.
	- get_next_line()을 호출하여 fd 3, fd 4, 다음에 다시 3, 4 등등을 읽을 수 있어야 한다.