## size_t가 무엇인가?
#### 정의
- **어떤 것의 크기를 나타내기 위한 자료형**. 어떤 배열의 length를 구하거나 index를 이용해서 접근할때 사용
- 플랫폼에 따라 다른 자료형을 쓰기 위해 typedef한 것
- 현재 사용하고 있는 os환경에 따라 크기가 달라짐
	- 현재 대부분의 os환경인 64bit 환경에서는 64bit로 컴파일됨
	- 64bit os에서는 unsigned long long 또는 unsigned long int 이런식으로 되어있을 것
#### 쓰는 이유
- C언어는 컴퓨터뿐만 아니라 다양한 플랫폼에서 사용됨
- 모든 자료형을 최소 요구사항만 있다. 컴파일러마다 크기의 범위는 다를 수 있다.
- 때문에 여러 플랫폼에 호환되도록 만들기 위해서 플랫폼마다 다른 범위를 가지는 size_t를 만들게 되었다.

## 메모리 관련 함수에 unsigned char를 사용하는 이유
- C 명세서에 unsigned char를 사용하라고 나와있기 때문에
	- Memset, memcpy 등의 함수는 이름과 같이 메모리의 정보 그대로를 복사하는 함수이다. 그 메모리가 나타내는 값(value)을 복사하는 게 아니라 메모리의 비트열을 그대로 복사하는 것이 목적인 굉장히 저수준(low-level)의 목적을 가지고 있다.
	- C 명세서에서는 이런 오브젝트의 비트열을 [[object representation]]이라고 한다.
	- [[object representation]]을 명세서에서는  "모든 n바이트의 객체는 unsigned char[n] 형태의 메모리에 복사 가능헤야 하며 이 때 그 비트열을 object representation이라고 정의한다"라고 정의되어 있다.
	- 이렇듯 정의 자체가 unsigned char에 의존하기 때문에 메모리 관련 함수에는 unsigned char를 사용한다.
- padding 문제를 발생하지 않게 하기 위해
- -0을 null로 인식하는 문제에서 자유롭기 위해 사용하기도 함.
## memset
#### unsigned char로 형변환 후 메모리 블록을 다룸
- 때문에 어떤 자료형이 들어오든 1byte씩 초기화를 함.
- ![[Pasted image 20231006155908.png]]
- **따라서 memset 함수를 초기화 목적으로 사용할 때는 반드시 0 혹은 NULL 값만 사용할것!**
#### memset을 왜 쓰는가?
- 정적, 혹은 동적 할당한 배열의 값을 초기화 하기 위해 사용함
- for문보다 속도측면에서 우월함 (시간복잡도에 따른 차이. PC의 설계 관점으로 어쩌구 하는데 잘 모르겠음)
## memmove
#### src와 dst의 메모리 영역이 겹치는 경우
- dst 주소값이 100이고 src의 주소값이 96이면, dst의 주소값에 src의 값이 저장되어 있을수 있음. 이런 경우에는 원본의 데이터를 갱신하기 때문에, 기존의 값을 제대로 복사할 수 없게됨
- 이를 예외처리하기 위해 dst의 주소가 src의 주소값보다 작은 경우와 큰 경우를 나누어 따로 구현함
## calloc
#### 어떤  역할을 하는가?
- size크기의 변수를 count개 만큼 저장할 수 있는 메모리 공간을 할당함.
- 할당된 공간의 값을 모두 0으로 초기화함.
#### malloc과의 차이점
- 자료형과 개수를 따로 인자로 받음
- malloc은 할당된 공간이 쓰레기 값으로 채워지지만, calloc은 size만큼 0으로 채워짐
#### malloc(0)?
- size가 0일때 malloc이 무엇을 리턴하는지는 라이브러리마다 다름.
	- C언어 표준에 따르면 "undefined behavior"로 지정되어 있기 때문에 구현자가 이에 대해 특별한 동작을 지정하지 않아도 됨.
	- 널 포인터를 리턴할수도 있고,
	- 널이 아닌 포인터를 리턴하지만 사용 불가능한 부분을 가리키고 있을 수 있음.
####  size_t의 범위를 넘어서는 경우
- 기존 malloc에 size_t의 범위를 넘는 수를 넣으면 오류를 출력하고 널 포인터를 반환
- 하지만 프로그램이 죽진 않고 그대로 진행됨
- 개인적으로 널 포인터를 출력함으로써 메모리 할당에 실패했다는 점을 인지만 하면 된다고 생각함.
## substr
#### len이 s의 범위를 벗어나는 경우
- len이 s의 범위를 벗어나는 경우 벗어나는 범위만큼 공간 낭비가 발생함
- 이에 대한 명확한 지시가 없음
- len을 아주 크게 넣으면 여러가지 문제가 생길 수 있다고 판단하여 len을 s의 길이 - start 만큼으로 제한함
- input에 따라 한칸의 메모리 낭비가 발생하지만 한칸정도는 괜찮다고 판단
#### start가 s의 길이보다 클 경우
- 인덱스가 문자열보다 크면 잘못된 접근이라고 판단하여 널 포인터 반환. malloc x
## lstclear
#### 왜  마지막에 *lst를 null로 초기화하는가?
- 더 이상 리스트에 어떤 노드도 남아있지 않는 상태를 나타내기 위해
- 잘못된 참조나 메모리 누수를 방지하기 위한 일종의 관행
	- null로 초기화하지 않으면, 나중에 코드에서 이 리스트를 사용하려 할 때 잘못된 데이터에 접근하거나 삭제된 노드를 또 다시 삭제하려는 문제가 발생할 수 있음

- atoi 오버플로우 잡기
- calloc 오버플로우 잡기
- 인자로 들어오는 포인터 널가드 확인
-